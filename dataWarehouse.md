data source -> ETL -> 数据仓库(企业级数仓) -> 数据集市(部门级数仓)
# 一、概述 #
## 数仓发展现状 ##
1. **新的索引**，不只是简单的B+树，如位图索引、连接索引和多维索引等
2. **实物化视图**，提前连接查询出结果减少OLAP的时间，视图是实际存在的表，随着时间推移会导致数据不一致的问题
3. **立方体计算(data cube)**，类似于实视图，在多维数仓中将cube中的数据预聚集处理，结果存储到立方体视图(datacube view)中，进行旋转切片切块下钻上翻等操作
4. **查询优化和并行处理**，在事实表上建立连接索引，利用连接索引，不会进行实际的表连接，减少时间
5. **分组聚集**

## 数仓基本特征 ##
1. **面向主题(object oriented)**将二维数据表分成不同的主题，面向主题建模分析
2. **集成的(integrate)**源数据存在同名异义，异名同义，单位长度等不一致的问题，需要将元数据清洗转化集成为分析型数据，用于主题分析
3. **稳定的(non-volatile)**主要是数据的查询和分析，很少会有增删改。适用于复杂的索引技术
4. **反映历史变化(time varient)**数据没有增删改，会在原数据集上追加新的数据，自带时间戳版本信息，过时的也可以移除

## 数仓的组织架构 ##
> 粒度：反映数据的细节程度。早期细节->当前细节->轻度综合级别->高度综合级别
> 
> 细粒度代表细节程度较高，综合程度低，偏向于源数据、底层数据；
> 
> 粗粒度代表细节程度较低，综合程度高，偏向于应用层数据

## 数据的存储层 ##
1. 存储的数据大概分为三部分：①ETL后的**业务数据**②数仓的**元数据**③针对不同主题生成的**数据集市**
2. 存储架构分为：**①缓冲区**，用于暂存ETL数据，正是导入之前用于预处理和缓存**②数仓**，存放处理后的数据，常见的组织形式有“多维数据库组织形式”和“基于关系数据库形式”**③数据集市**，面向具体的主题和业务部门进行高性能结构查询，具有较粗的粒度和适量的历史数据，响应快**④元数据**，类似于数据字典，描述源数据库和目标数据库的数据模型、物理结构以及相关匹配模式等重要信息

# 二、数仓的开发模型 #
## 开发模型概述 ##
高层概念模型(现实业务)->中层逻辑模型(机器逻辑)->底层物理模型(实际实现)和元数据模型设计
### 高层概念模型(现实业务) ###
1. **目的**是对数仓所涉及到的现实世界所有实体进行客观的分析抽象，确立数仓的“蓝图”
2. 明确主要的**主题域**和**工作边界**，确定**分析维度**(维度一般是离散型有确定数量，度量一般是连续型取值无限用于分析关心指标)
3. 常采用**ER模型**和**OO的分析方法**，用**信息包图**进行进一步细化概念模型

## 数据模型 ##
数据模型是抽象描述现实世界的一种工具和方法，是通过抽象的实体及实体之间联系的形式，来表示现实世界中事务的相互关系的一种映射。
在这里，数据模型表现的抽象的是实体和实体之间的关系，通过对实体和实体之间关系的定义和描述，来表达实际的业务中具体的业务关系。
**是实体关系的抽象定义描述。**

## 数据仓库建模阶段 ##
**业务建模**，这部分建模工作，主要包含以下几个部分：
> 划分整个单位的业务，一般按照业务部门的划分，进行各个部分之间业务工作的界定，理清各业务部门之间的关系。
> 深入了解各个业务部门的内具体业务流程并将其程序化。
> 提出修改和改进业务部门工作流程的方法并程序化。
> 数据建模的范围界定，整个数据仓库项目的目标和阶段划分。

**领域概念建模**，这部分得建模工作，主要包含以下几个部分：
> 抽取关键业务概念，并将之抽象化。
> 将业务概念分组，按照业务主线聚合类似的分组概念。
> 细化分组概念，理清分组概念内的业务流程并抽象化。
> 理清分组概念之间的关联，形成完整的领域概念模型。

**逻辑建模**，这部分的建模工作，主要包含以下几个部分：
> 业务概念实体化，并考虑其具体的属性
> 事件实体化，并考虑其属性内容
> 说明实体化，并考虑其属性内容

**物理建模**，这部分得建模工作，主要包含以下几个部分：
> 针对特定物理化平台，做出相应的技术调整
> 针对模型的性能考虑，对特定平台作出相应的调整
> 针对管理的需要，结合特定的平台，做出相应的调整
> 生成最后的执行脚本，并完善之。


## 数据建模技术 ##
**ER建模**和**关系建模**，专门针对数据仓库的**维度建模技术**
或者**范式建模**和**实体建模**

> 维度建模非常直观，紧紧围绕着业务模型，可以直观的反映出业务模型中的业务问题。不需要经过特别的抽象处理，即可以完成维度建模
> 维度建模法的缺点也是非常明显的，由于在构建星型模式之前需要进行大量的数据预处理，因此会导致大量的数据处理工作。而且，当业务发生变化，需要重新进行维度的定义时，往往需要重新进行维度数据的预处理。而在这些与处理过程中，往往会导致大量的数据冗余。

## 维度建模的三种模式 ##
维度建模(dimensional modeling)是专门用于分析型数据库、数据仓库、数据集市建模的方法。
> 它本身属于一种关系建模方法，但和之前在操作型数据库中介绍的关系建模方法相比增加了两个概念：
> 
> 维度表(dimension)
> 表示对分析主题所属类型的描述。比如"昨天早上张三在京东花费200元购买了一个皮包"。那么以购买为主题进行分析，可从这段信息中提取三个维度：时间维度(昨天早上)，地点维度(京东), 商品维度(皮包)。通常来说维度表信息比较固定，且数据量小。
> 
> 事实表(fact table)
> 表示对分析主题的度量。比如上面那个例子中，200元就是事实信息。事实表包含了与各维度表相关联的外码，并通过JOIN方式与维度表关联。事实表的度量通常是数值类型，且记录数会不断增加，表规模迅速增长。

**星型(1×事实表，n×维度表)
雪花型(1×事实表，n1×n2维度表)
星座型(m×事实表，n×维度表)**

**星形模式**
> **星形模式(Star Schema)**是最常用的维度建模方式，下图展示了使用星形模式进行维度建模的关系结构：
![星形模式](https://images2015.cnblogs.com/blog/903014/201603/903014-20160324180338683-1916113766.jpg)
星型模式之所以广泛被使用，在于针对各个维作了大量的预处理，如按照维进行预先的统计、分类、排序等。通过这些预处理，能够极大的提升数据仓库的处理能力。

**雪花模式(Snowflake Schema)**是对星形模式的扩展，
> 每个维表可继续向外连接多个子维表。下图为使用雪花模式进行维度建模的关系结构：
![雪花模式](https://images2015.cnblogs.com/blog/903014/201603/903014-20160324180236104-1134926519.jpg)
> 星形模式中的维表相对雪花模式来说要大，而且不满足规范化设计。雪花模型相当于将星形模式的大维表拆分成小维表，满足了规范化设计。然而这种模式在实际应用中很少见，因为这样做会导致开发难度增大，而数据冗余问题在数据仓库里并不严重。

**星座模式(Fact Constellations Schema)**也是星型模式的扩展。基于这种思想就有了星座模式：
![星座模式](https://images2015.cnblogs.com/blog/903014/201603/903014-20160324175828948-2089267269.jpg)
> 前面介绍的两种维度建模方法都是多维表对应单事实表，但在很多时候维度空间内的事实表不止一个，而一个维表也可能被多个事实表用到。在业务发展后期，绝大部分维度建模都采用的是星座模式。

雪花模式是将星型模式的维表进一步划分，使各维表均满足规范化设计。而星座模式则是允许星形模式中出现多个事实表。

## OLAP & OLTP ##
数据处理大致可以分成两大类：**联机事务处理OLTP**（on-line transaction processing）、**联机分析处理OLAP**（On-Line Analytical Processing）。

OLTP是传统的**关系型数据库**的主要应用，主要是基本的、日常的事务处理，例如银行交易。
OLAP是**数据仓库系统**的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 

OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，**强调并发**操作；
OLAP 系统则**强调数据分析**，强调SQL执行市场，强调磁盘I/O，**强调分区**等。

> OLTP，也叫联机事务处理（Online Transaction Processing），表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。典型的OLTP系统有电子商务系统、银行、证券等，如美国eBay的业务数据库，就是很典型的OLTP数据库。OLTP系统最容易出现瓶颈的地方就是CPU与磁盘子系统。

> OLAP，也叫联机分析处理（Online Analytical Processing）系统，有的时候也叫DSS决策支持系统，就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB/s的流量。磁盘子系统的吞吐量则往往取决于磁盘的个数

## DDS & OLAP & OLTP ##
> 联机分析处理（OLAP,On-line Analytical Processing），数据量大，DML少。使用数据仓库模板
> 
> 联机事务处理（OLTP,On-line Transaction Processing），数据量少，DML频繁，并行事务处理多，但是一般都很短。使用一般用途或事务处理模板。
> 
> 决策支持系统（DDS，Decision support system)，典型的操作是全表扫描，长查询，长事务，但是一般事务的个数很少，往往是一个事务独占系统。


## hive ##
将sql转化为操作单元，操作单元为基本单位
基于HDFS，元数据存于关系数据库
> Local模式：默认derby，基于内存
> 单用户模式：只支持一个连接
> 多用户模式：加了一个中间层MetaStoreServer，中间件维护关系数据库，客户端可以多个访问中间件

### hive数据类型 ###
varchar -> string
array_type/ map_type/struct_type

## HIVE - DDL ##
create [EXTERNAL] table person (
id int,
name string,
hobby array<string>,
address map<string,string>
)
PARTITIONED BY (age int)
ROW FORMAT DELIMITED
FIELDS TERMINATED BY ','
COLLECTION ITEMS TERMINATED BY '-'
MAP KEYS TERMINATED BY ':'
LINES TERMINATED BY '\n'
[LOCATION '/tmp/data_path'];

desc formatted TABLE_NAME
> 内部表和外部表
> table type：managed_table & external_type(有location，需要指明路径)
> 内部表由HIVE维护，外部表创建时需要指定HDFS目录；
> 删除时内部表会将结构以及路径和元数据全部删除，外部表只删除表结构，不删除路径以及元数据

## HIVE - DML ##
LOAD 比 INSERT 效率高
LOAD DATA LOCAL INPATH '/root/data' INTO TABLE person PARTITION (age=10)

HIVE是读检查，什么都能写，但是格式不对就读不出来

> 分区字段不用写到表的字段，而是在加载数据的时候会自动把partition加入到表的字段，且会产生对应的age=10目录，做扫描时候直接扫描age=10的文件目录即可
> 分区技巧，有粗粒度和细粒度。

加/删除分区
ALTER TABLE person ADD/DROP PARTITION (age=10, sex='boy')
## HIVE - Partition ##