1. 线程、线程池、锁
2. GC、JVM
3. Stringbuilder、Stringbuffer
4. List、ArrayList、HashMap
5. final 关键字transient不可被序列化
6. 子类父类虚函数
7. 抽象函数interface
> 重载，继承，多态，接口，虚函数，并发，线程

### 面试题###
|@| String、StringBuffer、StringBuilder的区别，怎么理解String不变性
> 1. 执行速度方面的比较：StringBuilder(字符串变量) >  StringBuffer(字符串变量)  >  String(字符串常量)
> 2. StringBuilder：线程非安全的，适用于单线程；StringBuffer：线程安全的适用于多线程
> 3. StringBuilder是可变对象，用来高效拼接字符串，且支持链式操作，实现链式操作的关键是返回实例本身
|@| ==和equals的区别，如果重写了equals()不重写hashCode()会发生什么
|@| HashMap原理，为什么用红黑树，红黑树的特点
> implements Map接口实现;线程不安全;允许使用null(仅一个键为null)和null值;无序;避免进行多次扩容;jdk1.8后对HashMap的改进:链表长度超过阈值时，将链表转换为红黑树


|@| HashMap和HashTable的区别，HashMap怎么解决hash冲突
> 1. Hashtable是线程安全(实现方法里面都添加了synchronized关键字来确保线程同步)性能较高，而HashMap则非线程安全;
> 2. HashTable实现了Map接口和Dictionary抽象类;
> 3. HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75;HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1;
> 4. Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模,HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模


|@| 讲讲ConcurrentHashMap，ConcurrentHashMap怎么保证线程安全，HashTable怎么保证线程安全
|@| HashSet的底层实现，是不是线程安全的
|@| ArrayList和LinkedList的区别，是不是线程安全的
|@| 内部类，什么是匿名内部类
|@| java为什么不能多继承(子类有多个父类，并且具有他们的特征)
> 单继承易读易维护语义清晰逻辑清楚，体现**类的本质**;若一个子类继承的多个父类拥有相同方法，同时子类并未覆盖该方法（若覆盖，则直接使用子类中该方法），那么调用该方法时将无法确定调用哪个父类的方法


|@| 讲一下java抽象类abstract和接口interface/implements(接口中成员变量均默认为 static final)
> 1. 接口指明了一个类必须要做什么和不能做什么
> 2. 接口是解决Java无法使用多继承的一种手段 
> 3. 抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类.抽象类内部可能包含非final的变量，但是在接口中存在的变量一定是final,public,static的 
> 4. 不能直接去实例化一个接口 
> 5. abstract class知道一类物体的部分行为（和属性），但是不清楚另一部分的行为（和属性），所以我不能自己实例化；interface不能定义（它只做了声明）共同的行为，事实上它也不能定义“非常量”的变量

|@| java单例模式的实现，懒汉、饿汉
|@| 进程与线程的区别，多进程和多线程的区别
> 1. 线程是CPU独立运行和独立调度的基本单位；进程是资源分配的基本单位；是执行着的应用程序。进程和线程都是操作系统所运行的程序运行的基本单元
> 2. 进程是**资源分配**的最小单位，线程是**程序执行**的最小单位
> 3. 进程有自己的独立地址空间；线程是共享进程中的数据的，使用相同的地址空间，开销和切换比较小
> 4. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行
> 5. 多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间


|@| java实现多线程的方式
> 1. 继承Thread类；实现Runnable接口；应用程序可以使用Executor框架来创建线程池
> 2. Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用
> 3. **就绪(Runnable)**:线程准备运行，不一定立马就能开始执行。**运行中(Running)**：进程正在执行线程的代码。**等待中(Waiting)**:线程处于阻塞的状态，等待外部的处理结束。**睡眠中(Sleeping)**：线程被强制睡眠。**I/O阻塞(Blocked on I/O)**：等待I/O操作完成。**同步阻塞(Blocked on Synchronization)**：等待获取锁。**死亡(Dead)**：线程完成了执行


|@| 讲讲设计模式，最常用哪种设计模式，单例模式的实现方式
|@| 进程和线程，Java实现多线程的方式，什么是线程安全，怎么保证多线程线程安全
|@| volatile怎么保证可见性，synchronized和lock的区别，synchronized的底层实现
|@| sleep和wait的区别，sleep会不会释放锁，notify和notifyAll的区别
|@| 什么情况会发生死锁，死锁的处理方法
> 1. 多线程产生死锁的四个必要条件：**互斥条件**：一个资源每次只能被一个进程使用。**保持和请求条件**：一个进程因请求资源而阻塞时，对已获得资源保持不放。**不可剥夺调教**：进程已获得资源，在未使用完成前，不能被剥夺。**循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。
> 2. 最简单的就是**破环循环等待条件**：指定获取锁的顺序，并强制线程按照指定的顺序获取锁

|@| 可重入锁的可重入性是什么意思，哪些是可重入锁
|@| 为什么要用线程池，线程池的好处
|@| JVM垃圾处理方法，对象什么时候进入老年代，什么时候进行FullGC
|@| Java堆溢出问题怎么处理，内存泄漏和内存溢出的区别 

## 面向对象的基本原则 ##
> s( Single-Resposibility Principle ): 单一职责原则
> o( Open-Closed principle ): 开放封闭原则
> l( Liskov-Substituion Principle ): 里氏原则
> i( Interface-Segregation Principle ): 接口隔离原则
> d( Dependecy-Inversion Principle ): 依赖倒置原则
> 一个单词：立方体(solid)
> 
> **单一职责**原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。 
> **开放封闭**原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 
> **Liskov替换**原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。 
> **接口隔离**原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口
> **依赖倒置**原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 

## 线程同步 ##
> **喂，SHE**：喂（Vector）S（Stack）H（hashtable）E（enumeration）
> 线程安全的同步的类：
> **vector**：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。
> **statck**：堆栈类，先进后出
> **hashtable**：就比hashmap多了个线程安全
> **enumeration**：枚举，相当于迭代器
> 除了这些之外，其他的都是非线程安全的类和接口。

## 线程安全 ##
> 进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
> 线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。
![线程安全](https://uploadfiles.nowcoder.com/images/20160708/887525_1467945811956_2FA6EA0EFC9909BB317917FC1362F6AE)

> LinkedList 和 ArrayList 都是不同步的，线程不安全；
> Vector 和 Stack 都是同步的，线程安全；
> Set是线程不安全的； 
> Hashtable的方法是同步的，线程安全；
> HashMap的方法不是同步的，线程不安全

## 线程结束 ##
> 1、run方法执行完成，线程正常结束
> 2、线程抛出一个未捕获的Exception或者Error。可以通过其他线程调用pthread_cancel（）函数来终止另一个线程
> 3、直接调用该线程的Stop方法结束线程（不建议使用，容易导致死锁）
> 调用sleep()方法或者wait()方法时，只是暂时停止了该线程的运行，不是终止线程
> 当一个优先级高的线程进入就绪状态时，它只是有较高的概率能够抢到CPU的执行权，不是一定就能抢到执行权

## 线程的执行体 ##
> run()用于定义线程的执行体
> start()线程开启的方法，线程状态从new变成了runnable
![线程执行体](https://uploadfiles.nowcoder.com/images/20180701/3807435_1530424646801_3658A873352D1D5FB9EF74D9F9F1F0B5)
**wait() 与  notify/notifyAll()**
 wait() 与  notify/notifyAll() 是放在同步代码块中的，因此线程在执行它们时，肯定是进入了临界区中的，即该线程肯定是获得了锁的。
当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。
 当执行notify/notifyAll方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。
从这里可以看出，notify/notifyAll()执行后，并不立即释放锁，而是要等到执行完临界区中代码后，再释放。故，在实际编程中，我们应该尽量在线程调用notify/notifyAll()后，立即退出临界区。即不要在notify/notifyAll()后面再写一些耗时的代码。
wait() 与  notify/notifyAll()都是放在同步代码块中才能够执行的。如果在执行wait() 与  notify/notifyAll() 之前没有获得相应的对象锁，就会抛出：java.lang.IllegalMonitorStateException异常。


## ThreadLocal ##
> 1. ThreadLocal的类声明：public class ThreadLocal<T>。可以看出ThreadLocal并没有继承自Thread，也没有实现Runnable接口。
> 2. ThreadLocal类为每一个线程都维护了自己独有的**变量拷贝**。每个线程都拥有了自己独立的一个变量。所以ThreadLocal重要作用并不在于多线程间的数据共享，而是**数据的独立**。由于每个线程在访问该变量时，读取和修改的，都是自己独有的那一份变量拷贝，不会被其他线程访问，变量被彻底封闭在每个访问的线程中。
> 3. ThreadLocal中定义了一个哈希表用于为每个线程都提供一个变量的副本
> 
> ThreadLocal继承Object，相当于没继承任何特殊的。
> ThreadLocal没有实现任何接口。
> ThreadLocal并不是一个Thread，而是Thread的局部变量。

## 位运算 ##
> 运算对象为数字的补码，而不是二进制码。当补码的符号位为1时，说明该补码对应的是负数，所以根据补码求原码的时候遵循负数的原则，补码取反加一。如果符号位为0时，则该补码对应的原码与其相同。
> -3：
> 1000 0011 （原码）
> 1111 1100 （反码）
> 1111 1101 （补码）（这是-3在计算机中的表示形式）
> ~（-3）：
> 0000 0010 （补码）（~（-3）在计算机中的表示形式）
> 所以~（-3）=4
>  
> 1：
> 0000 0001 （原码，反码，补码）
> ~1：
> 1111 1110 （补码）（~1在计算机中的表示形式）
> 1000 0010 （原码）
> ~1=-2


## ArrayList 、 LinkedList 、 HashMap ##
> HashMap实现Map接口，它允许任何类型的键和值对象，并允许将null用作键或值
> ArrayList和LinkedList均实现了List接口
> ArrayList的访问速度比LinkedList快
> 
> Hashtable不允许 null 值(key 和 value 都不可以)，HashMap允许 null 值(key和value都可以)。 ArrayList和LinkedList均实现了List接口
> ArrayList基于数组实现，随机访问更快
> LinkedList基于链表实现，添加和删除更快

> A、HashMap实现了Map接口的，它的Key和Value都可以是null，但是Hashtable种，Key和Value都不能是null。
> B、ArrayList与LinkedList都实现了List接口，继承了AbstractList类。ArrayList是数组方式存储，也就是顺序存储，LinkedList是链式存储。LinkedList方便删除添加，ArrayList方便查找
> C、ArrayList底层是动态数组是实现，随机位置添加和删除，都需要移动数组的数据，而LinkedList底层是双向链表，只需要修改Node节点的引用。
> D、随机访问数组要比链表块
![](https://uploadfiles.nowcoder.com/images/20180705/3807435_1530799430432_DBD7499309F7A0C283CA6E755CC5E6DA)

## Servlet&CGI ##
> 当用户浏览器发出一个Http/CGI的请求，或者说 调用一个CGI程序的时候，服务器端就要新启用一个进程 (而且是每次都要调用)，调用CGI程序越多(特别是访问量高的时候)，就要消耗系统越多的处理时间，只剩下越来越少的系统资源，对于用户来说，只能是漫长的等待服务器端的返回页面了
> Servlet充分发挥了服务器端的资源并高效的利用。每次调用Servlet时并不是新启用一个进程 ，而是在一个Web服务器的进程敏感词享和分离线程，而线程最大的好处在于可以共享一个数据源，使系统资源被有效利用


## HTTP状态 ##
**1xx（临时响应）**
表示临时响应并需要请求者继续执行操作的状态码。

> 100（继续）	请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
> 
> 101（切换协议）	请求者已要求服务器切换协议，服务器已确认并准备切换。

**2xx （成功）**
表示成功处理了请求的状态码。

> 200（成功）	服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。
> 
> 201（已创建）	请求成功并且服务器创建了新的资源。
> 
> 202（已接受）	服务器已接受请求，但尚未处理。
> 
> 203（非授权信息）	服务器已成功处理了请求，但返回的信息可能来自另一来源。
> 
> 204（无内容）	服务器成功处理了请求，但没有返回任何内容。
> 
> 205（重置内容）	服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。
> 
> 206（部分内容）	服务器成功处理了部分 GET 请求。

**3xx （重定向） **
要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。

> 300（多种选择）	针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
> 
> 301（永久移动）	请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。
> 
> 302（临时移动）	服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。
> 
> 303（查看其他位置）	请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。
> 
> 304（未修改）	
> 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。
> 
> 305（使用代理）	请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。
> 
> 307（临时重定向）	服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 <a href=answer.py?answer=>301</a>代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。

**4xx（请求错误） **
这些状态码表示请求可能出错，妨碍了服务器的处理。

> 400（错误请求）	服务器不理解请求的语法。
> 
> 401（未授权）	请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。
> 
> 403（禁止）	服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。
> 
> 404（未找到）
> 	
> 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具"诊断"标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在"诊断"标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。
> 405（方法禁用）	禁用请求中指定的方法。
> 
> 406（不接受）	无法使用请求的内容特性响应请求的网页。
> 
> 407（需要代理授权）	此状态码与 <a href=answer.py?answer=35128>401（未授权）</a>类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。
> 
> 408（请求超时）	服务器等候请求时发生超时。
> 
> 409（冲突）	服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。
> 
> 410（已删除）	如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。
> 
> 411（需要有效长度）	服务器不接受不含有效内容长度标头字段的请求。
> 
> 412（未满足前提条件）	服务器未满足请求者在请求中设置的其中一个前提条件。
> 
> 413（请求实体过大）	服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
> 
> 414（请求的 URI 过长）	请求的 URI（通常为网址）过长，服务器无法处理。
> 
> 415（不支持的媒体类型）	请求的格式不受请求页面的支持。
> 
> 416（请求范围不符合要求）	如果页面无法提供请求的范围，则服务器会返回此状态码。
> 
> 417（未满足期望值）	服务器未满足"期望"请求标头字段的要求。

**5xx（服务器错误）**
这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。

> 500（服务器内部错误）	服务器遇到错误，无法完成请求。
> 
> 501（尚未实施）	服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。
> 
> 502（错误网关）	服务器作为网关或代理，从上游服务器收到无效响应。
> 
> 503（服务不可用）	服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
> 
> 504（网关超时）	服务器作为网关或代理，但是没有及时从上游服务器收到请求。
> 
> 505（HTTP 版本不受支持）	服务器不支持请求中所用的 HTTP 协议版本。

![TCP&UDP](https://uploadfiles.nowcoder.com/images/20190421/4206388_1555855001078_3C367271FFE76FF6DEE3D39D4C6CCD6A)
**TCP&UDP**
![OSI](https://uploadfiles.nowcoder.com/images/20190421/4206388_1555855008940_6F40E7C2ED3F3E542B4B5DE78D5E0CB9)
**OSI**

## String类型的认识以及编译器优化 ##
> Java中String不是基本类型，但是有些时候和基本类型差不多，如String b =  "tao" ; 可以对变量直接赋值，而不用 new 一个对象（当然也可以用 new）。所以String这个类型值得好好研究下。字符串在java中存储在**字符串常量区**。
> Java中的**变量和基本类型的值存放于栈内存**，而**new出来的对象本身存放于堆内存**，**指向对象的引用还是存放在栈内存**。
> eg：

	int  i=1;
	String s =  new  String( "Hello World" );
![堆栈](http://static.oschina.net/uploads/img/201305/28181619_ugB3.jpg)
> 变量i和s以及1存放在栈内存，而s指向的对象”Hello World”存放于堆内存。
> 栈内存的一个特点是数据共享，这样设计是为了减小内存消耗，前面定义了i=1，i和1都在栈内存内，如果再定义一个j=1，此时将j放入栈内存，然后查找栈内存中是否有1，如果有则j指向1。如果再给j赋值2，则在栈内存中查找是否有2，如果没有就在栈内存中放一个2，然后j指向2。也就是如果常量在栈内存中，就将变量指向该常量，如果没有就在该栈内存增加一个该常量，并将变量指向该常量。
![堆栈](http://static.oschina.net/uploads/img/201305/28181619_TJmL.jpg)
> 如果j++，这时指向的变量并不会改变，而是在栈内寻找新的常量（比原来的常量大1），如果栈内存有则指向它，如果没有就在栈内存中加入此常量并将j指向它。这种基本类型之间比较大小和我们逻辑上判断大小是一致的。如定义i和j是都赋值1，则i==j结果为true。==用于判断两个变量指向的地址是否一样。i==j就是判断i指向的1和j指向的1是同一个吗？当然是了。对于直接赋值的字符串常量（如String s=“Hello World”；中的Hello World）也是存放在栈内存中，而new出来的字符串对象（即String对象）是存放在堆内存中。如果定义String s=“Hello World”和String w=“Hello World”，s==w吗？肯定是true，因为他们指向的是同一个Hello World。
![堆栈](http://static.oschina.net/uploads/img/201305/28181619_E8BZ.jpg)
> 堆内存没有数据共享的特点，前面定义的String s =  new  String( "Hello World" );后，变量s在栈内存内，Hello World 这个String对象在堆内存内。如果定义String w = new  String( "Hello World" );，则会在堆内存创建一个新的String对象，变量w存放在栈内存，w指向这个新的String对象。堆内存中不同对象（指同一类型的不同对象）的比较如果用==则结果肯定都是false，比如s==w？当然不等，s和w指向堆内存中不同的String对象。如果判断两个String对象相等呢？用equals方法
![堆栈](http://static.oschina.net/uploads/img/201305/28181619_uF6N.jpg)
> 对于字符串常量的相加，在编译时直接将字符串合并，而不是等到运行时再合并。也就是说

> String a =  "tao" + "bao" ;和String a =  "taobao" ;编译出的字节码是一样的。所以等到运行时，根据上面说的栈内存是数据共享原则，a和MESSAGE指向的是同一个字符串。而对于后面的(b+c)又是什么情况呢？b+c只能等到运行时才能判定是什么字符串，编译器不会优化，想想这也是有道理的，编译器怕你对b的值改变，所以编译器不会优化。运行时b+c计算出来的"taobao"和栈内存里已经有的"taobao"是一个吗？不是。b+c计算出来的"taobao"应该是放在堆内存中的String对象。这可以通过System. out .println( (b+c)== MESSAGE );的结果为false来证明这一点。如果计算出来的b+c也是在栈内存，那结果应该是true。Java对String的相加是通过StringBuffer实现的，先构造一个StringBuffer里面存放”tao”,然后调用append()方法追加”bao”，然后将值为”taobao”的StringBuffer转化成String对象。StringBuffer对象在堆内存中，那转换成的String对象理所应当的也是在堆内存中。下面改造一下这个语句System. out .println( (b+c).intern()== MESSAGE );结果是true， intern() 方法会先检查 String 池 ( 或者说成栈内存 ) 中是否存在相同的字符串常量，如果有就返回。所以 intern()返回的就是MESSAGE指向的"taobao"。再把变量b和c的定义改一下，

	final  String b =  "tao" ;final  String c =  "bao" ;
	System. out .println( (b+c)== MESSAGE );

> 现在b和c不可能再次赋值了，所以编译器将b+c编译成了”taobao”。因此，这时的结果是true。
> 在字符串相加中，只要有一个是非final类型的变量，编译器就不会优化，因为这样的变量可能发生改变，所以编译器不可能将这样的变量替换成常量。例如将变量b的final去掉，结果又变成了false。这也就意味着会用到StringBuffer对象，计算的结果在堆内存中。
>  如果对指向堆内存中的对象的String变量调用intern()会怎么样呢？实际上这个问题已经说过了，(b+c).intern()，b+c的结果就是在堆内存中。对于指向栈内存中字符串常量的变量调用intern()返回的还是它自己，没有多大意义。它会根据堆内存中对象的值，去查找String池中是否有相同的字符串，如果有就将变量指向这个string池中的变量。

	String a = "tao"+"bao";String b = new String("taobao");
	System.out.println(a==MESSAGE); //true
	System.out.println(b==MESSAGE);  //false
	b = b.intern();
	System.out.println(b==MESSAGE); //true
	System. out .println(a==a.intern());  //true

## 子类继承父类 ##
**子类将继承父类所有的数据域和方法**

> 在一个子类被创建的时候，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者合起来形成一个子类的对象。所以所谓的继承使子类拥有父类所有的属性和方法其实可以这样理解，子类对象确实拥有父类对象中所有的属性和方法，但是父类对象中的私有属性和方法，子类是无法访问到的，只是拥有，但不能使用。就像有些东西你可能拥有，但是你并不能使用。所以子类对象是绝对大于父类对象的，所谓的子类对象只能继承父类非私有的属性及方法的说法是错误的。可以继承，只是无法访问到而已。

## 类的加载顺序 ##
> (1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)
> (2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )
> (3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )
> (4) 父类构造函数
> (5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )
> (6) 子类构造函数
> 其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)

## 堆栈 ##
> **堆区**：只存放类对象，线程共享；
> **方法区**：又叫静态存储区，存放class文件和静态数据，线程共享;
> **栈区**：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;

## Object类 ##
> 都是Object类中的方法
> wait指线程处于进入等待状态，形象地说明为“等待使用CPU”，此时线程不占用任何资源，不增加时间限制。
> notify():  是唤醒一个正在等待该对象的线程。   
> notifyAll(): 唤醒所有正在等待该对象的线程。
> sleep 是Thread类中的方法
> 
> wait 和 sleep的区别：
> sleep指线程被调用时，占着CPU不工作，形象地说明为“占着CPU睡觉”，此时，系统的CPU部分资源被占用，其他线程无法进入，会增加时间限制

## 静态方法&实例方法 ##
> **类方法**就是**静态方法**。其它的就是**实例方法**
> 实例方法可以对当前对象的实例变量进行操作，也可以对类变量进行操作，但*类方法不能访问实例变量*。实例方法必须由实例对象来调用，而类方法除了可由实例对象调用外，还可以由类名直接调用。
> 另外，在类方法中*不能使用 this 或 super*。 关于类方法的使用，有如下一些限制：
> 1 在类方法中不能引用对象变量。
> 2 在类方法中不能使用super、this关键字。
> 3 类方法不能调用类中的对象方法。
> 与类方法相比，实例方法*几乎没有什么限制*：
> 1 实例方法可以引用对象变量（这是显然的），也可以引用类变量。
> 2 实例方法中可以使用super、this关键字。
> 3 实例方法中可以调用类方法。

	class Super {
	 private static void a() {
	 }//类方法
	 public static void b() {
	 }//类方法
	 public void c() {
	 }//实例方法
	 private void d() {
	 }//实例方法
	}
	public class Son extends Super {
	 public static void main(String args[]) {
	 Super s = new Super();
	 Super.a();//B错误，因a为私有的类方法，外类不可访问
	 Super.b();//b为公有类方法，外类可用 类名.方法名 访问
	 s.c();//c为公有实例方法，外类可用 实例名.方法名 访问
	 s.d();//A错误，因d为私有实例方法，外类不可访问
	 }
	}

## 控制反转IOC & 依赖注入DI ##
> 依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；而控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。

# 关键字 #
## volatile关键字 ##
> volatile关键字用在多线程同步中，可保证读取的可见性
> JVM保证从主内存加载到线程工作内存的值是最新的
> volatile能禁止进行指令重排序
> 不能保证线程安全

> volatile是java中的一个类型修饰符。它是被设计用来修饰被不同线程访问和修改的变量。如果不加入volatile，基本上会导致这样的结果：要么无法编写多线程程序，要么编译器 失去大量优化的机会。
> 1，可见性
> 可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。
> 2，禁止指令重排序优化
> 禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。


## OJ ##

	import java.util.*;
	 
	public class Main {
	    public static void main(String[] args) {
	        Scanner sc = new Scanner(System.in);
	        int n = sc.nextInt(), m = sc.nextInt();
	        ArrayList<Set<Integer>> man = new ArrayList<>(), women = new ArrayList<>();
	        for (int i=0; i<=n; i++) { man.add(new HashSet<>()); }
	        for (int i=0; i<=m; i++) { women.add(new HashSet<>()); }
	        for (int i=1; i<=n; i++) {
	            int pn = sc.nextInt();
	            for (int j=0; j<pn; j++) {
	                int wp = sc.nextInt();
	                man.get(i).add(wp);
	                women.get(wp).add(i);
	            }
	        }
	        for (int i=1; i<=m; i++) {
	            int pn = sc.nextInt();
	            for (int j=0; j<pn; j++) {
	                int wp = sc.nextInt();
	                women.get(i).add(wp);
	                man.get(wp).add(i);
	            }
	        }
	        int ans = 0;
	        for (int i=1; i<=n; i++) {
	            ans = Math.max(man.get(i).size(), ans);
	        }
	        for (int i=1; i<=m; i++) {
	            ans = Math.max(women.get(i).size(), ans);
	        }
	        System.out.println(ans);
	    }
	}
